/**
 * API Route: Convert LaTeX to Word using Pandoc
 * 
 * This endpoint receives LaTeX content and returns a DOCX file
 * generated by Pandoc with proper manuscript formatting.
 * Uses NEJM citation style for medical journal submissions.
 */

import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFile, readFile, unlink, mkdir } from 'fs/promises';
import { join } from 'path';
import { tmpdir } from 'os';
import { randomUUID } from 'crypto';

const execAsync = promisify(exec);

// Path to NEJM CSL file and reference document
const NEJM_CSL_PATH = join(process.cwd(), 'public', 'pandoc-assets', 'nejm.csl');
const REFERENCE_DOC_PATH = join(process.cwd(), 'public', 'pandoc-assets', 'reference.docx');

export async function POST(request: NextRequest) {
    const tempDir = join(tmpdir(), 'pandoc-convert', randomUUID());
    const texPath = join(tempDir, `manuscript.tex`);
    const bibPath = join(tempDir, `manuscript.bib`);
    const docxPath = join(tempDir, `manuscript.docx`);
    const figuresDir = join(tempDir, 'figures');

    try {
        // Parse request body
        const { latex, filename = 'manuscript', images = [] } = await request.json();

        if (!latex || typeof latex !== 'string') {
            return NextResponse.json(
                { error: 'Missing or invalid LaTeX content' },
                { status: 400 }
            );
        }

        // Create temp directory
        await mkdir(tempDir, { recursive: true });

        // Detect font from LaTeX and map to Word-compatible font name
        const fontPackageMap: Record<string, string> = {
            'mathptmx': 'Times New Roman',
            'times': 'Times New Roman',
            'txfonts': 'Times New Roman',
            'newtxtext': 'Times New Roman',
            'stix': 'Times New Roman',
            'helvet': 'Helvetica',
            'avant': 'Avant Garde',
            'palatino': 'Palatino Linotype',
            'newpxtext': 'Palatino Linotype',
            'bookman': 'Bookman Old Style',
            'charter': 'Charter',
            'utopia': 'Utopia',
            'fourier': 'Utopia',
            'lmodern': 'Latin Modern Roman',
            'libertine': 'Linux Libertine',
            'garamondx': 'Garamond',
            'ebgaramond': 'EB Garamond',
            'cochineal': 'Cochineal',
            'baskervaldx': 'Baskerville',
            'sourcesanspro': 'Source Sans Pro',
            'sourceserifpro': 'Source Serif Pro',
            'roboto': 'Roboto',
            'opensans': 'Open Sans',
            'cabin': 'Cabin',
            'fira': 'Fira Sans',
        };

        let detectedFont = 'Times New Roman'; // Default fallback
        for (const [pkg, font] of Object.entries(fontPackageMap)) {
            // Match \usepackage{pkg} or \usepackage[...]{pkg}
            const fontRegex = new RegExp(`\\\\usepackage(?:\\[[^\\]]*\\])?\\{${pkg}\\}`, 'i');
            if (fontRegex.test(latex)) {
                detectedFont = font;
                console.log(`DEBUG: Detected font package '${pkg}' -> using '${font}'`);
                break;
            }
        }
        console.log(`DEBUG: Using font '${detectedFont}' for Word export`);

        // 2. Font Size Detection (from documentclass)
        // Word uses half-points: 12pt = 24 half-points
        let detectedFontSizeHalfPt = 24; // Default 12pt
        const fontSizeMatch = latex.match(/\\documentclass\[(\d+)pt\]/);
        if (fontSizeMatch) {
            const ptSize = parseInt(fontSizeMatch[1]);
            detectedFontSizeHalfPt = ptSize * 2;
            console.log(`DEBUG: Detected font size: ${ptSize}pt -> ${detectedFontSizeHalfPt} half-points`);
        }

        // 3. Line Spacing Detection
        // Word line spacing: single=240, 1.5=360, double=480 (in twips)
        let detectedLineSpacing = 240; // Default single
        if (/\\doublespacing/.test(latex)) {
            detectedLineSpacing = 480;
            console.log('DEBUG: Detected double spacing');
        } else if (/\\onehalfspacing/.test(latex)) {
            detectedLineSpacing = 360;
            console.log('DEBUG: Detected 1.5 spacing');
        }

        // 4. Paragraph Indent Detection (Word uses twips: 1pt = 20 twips)
        let detectedParIndent = 720; // Default 0.5in
        const parIndentMatch = latex.match(/\\setlength\{\\parindent\}\{(\d+(?:\.\d+)?)(pt|em|in|cm)?\}/);
        if (parIndentMatch) {
            const value = parseFloat(parIndentMatch[1]);
            const unit = parIndentMatch[2] || 'pt';
            if (unit === 'pt') detectedParIndent = Math.round(value * 20);
            else if (unit === 'em') detectedParIndent = Math.round(value * detectedFontSizeHalfPt * 10);
            else if (unit === 'in') detectedParIndent = Math.round(value * 1440);
            else if (unit === 'cm') detectedParIndent = Math.round(value * 567);
            console.log(`DEBUG: Detected parindent: ${value}${unit} -> ${detectedParIndent} twips`);
        }

        // 5. Paragraph Skip (space between paragraphs)
        let detectedParSkip = 0; // Default no extra space
        const parSkipMatch = latex.match(/\\setlength\{\\parskip\}\{(\d+(?:\.\d+)?)(pt|em|in|cm)?\}/);
        if (parSkipMatch) {
            const value = parseFloat(parSkipMatch[1]);
            const unit = parSkipMatch[2] || 'pt';
            if (unit === 'pt') detectedParSkip = Math.round(value * 20);
            else if (unit === 'em') detectedParSkip = Math.round(value * detectedFontSizeHalfPt * 10);
            else if (unit === 'in') detectedParSkip = Math.round(value * 1440);
            else if (unit === 'cm') detectedParSkip = Math.round(value * 567);
            console.log(`DEBUG: Detected parskip: ${value}${unit} -> ${detectedParSkip} twips`);
        }

        // 6. Margin Detection (from geometry package) - 1in = 1440 twips
        interface Margins { top: number; bottom: number; left: number; right: number; }
        let detectedMargins: Margins = { top: 1440, bottom: 1440, left: 1440, right: 1440 };

        const uniformMarginMatch = latex.match(/\\usepackage\[margin=(\d+(?:\.\d+)?)(in|cm|mm)?\]/);
        if (uniformMarginMatch) {
            const value = parseFloat(uniformMarginMatch[1]);
            const unit = uniformMarginMatch[2] || 'in';
            let twips: number;
            if (unit === 'in') twips = Math.round(value * 1440);
            else if (unit === 'cm') twips = Math.round(value * 567);
            else if (unit === 'mm') twips = Math.round(value * 56.7);
            else twips = 1440;
            detectedMargins = { top: twips, bottom: twips, left: twips, right: twips };
            console.log(`DEBUG: Detected uniform margin: ${value}${unit} -> ${twips} twips`);
        } else {
            const geometryMatch = latex.match(/\\usepackage\[([^\]]+)\]\{geometry\}/);
            if (geometryMatch) {
                const opts = geometryMatch[1];
                const parseMargin = (name: string): number | null => {
                    const m = opts.match(new RegExp(`${name}=(\\d+(?:\\.\\d+)?)(in|cm|mm)?`));
                    if (!m) return null;
                    const val = parseFloat(m[1]);
                    const u = m[2] || 'in';
                    if (u === 'in') return Math.round(val * 1440);
                    if (u === 'cm') return Math.round(val * 567);
                    if (u === 'mm') return Math.round(val * 56.7);
                    return Math.round(val * 1440);
                };
                const top = parseMargin('top') ?? parseMargin('tmargin');
                const bottom = parseMargin('bottom') ?? parseMargin('bmargin');
                const left = parseMargin('left') ?? parseMargin('lmargin');
                const right = parseMargin('right') ?? parseMargin('rmargin');
                if (top !== null) detectedMargins.top = top;
                if (bottom !== null) detectedMargins.bottom = bottom;
                if (left !== null) detectedMargins.left = left;
                if (right !== null) detectedMargins.right = right;
            }
        }

        console.log('DEBUG: Style detection complete:', {
            font: detectedFont,
            fontSize: `${detectedFontSizeHalfPt / 2}pt`,
            lineSpacing: detectedLineSpacing === 480 ? 'double' : detectedLineSpacing === 360 ? '1.5' : 'single',
            parIndent: `${detectedParIndent} twips`,
            parSkip: `${detectedParSkip} twips`,
            margins: detectedMargins,
        });

        // Handle images if provided
        if (images && Array.isArray(images) && images.length > 0) {
            await mkdir(figuresDir, { recursive: true });

            for (const img of images) {
                if (img.name && img.data) {
                    try {
                        const cleanName = img.name.replace(/^figures\//, ''); // Remove 'figures/' prefix if present in name
                        const imgPath = join(figuresDir, cleanName);
                        // Handle base64 data (strip prefix if exists)
                        const base64Data = img.data.includes(',') ? img.data.split(',')[1] : img.data;
                        await writeFile(imgPath, Buffer.from(base64Data, 'base64'));
                    } catch (e) {
                        console.error(`Failed to write image ${img.name}:`, e);
                    }
                }
            }
        }

        // Pre-process LaTeX for better Pandoc compatibility
        let processedLatex = latex;

        // 0. GLOBAL CLEANUP (Run first)
        // Fix thousand separator like 7{,}615 -> 7,615 GLOBALLY
        // The {,} is a LaTeX construct for proper thousand separators
        // We need to match the literal braces: \{ and \} in regex
        processedLatex = processedLatex.replace(/\{,\}/g, ',');

        // Also handle any numbers that might have the full math-mode format: ${...}$
        // e.g., 100{,}000 should become 100,000
        // This is already handled by the above, but let's also clean up any stray single braces around numbers
        // that might confuse Pandoc table parsing
        // Pattern: single digit followed by comma inside braces like {7,615} -> 7,615
        // Actually, let's be more careful: just ensure no leftover braces around table numbers

        // Handle cases where numbers might have extra braces: {7},{615} -> 7,615
        processedLatex = processedLatex.replace(/\{(\d+)\},\{(\d+)\}/g, '$1,$2');
        // Handle {number} -> number (stray braces around single numbers)
        processedLatex = processedLatex.replace(/\{(\d+(?:,\d+)*)\}/g, '$1');

        // 1. Explicit Numbering Injection
        // Pandoc to Docx doesn't auto-number figures/tables well without filters. 
        // We will manually inject "Figure N. " and "Table N. " into the captions.

        // Figures
        let figCount = 0;
        const figureLabelMap = new Map<string, number>(); // Maps label names to figure numbers

        processedLatex = processedLatex.replace(/\\begin\{figure\}([\s\S]*?)\\end\{figure\}/g, (match, content) => {
            figCount++;

            // Extract any \label{fig:...} or \label{figure:...} from this figure block
            const labelMatch = content.match(/\\label\{(fig:[^}]+|figure:[^}]+)\}/);
            if (labelMatch) {
                figureLabelMap.set(labelMatch[1], figCount);
            }

            // Check if caption already has "Figure X" (avoid double numbering if user added it)
            if (content.match(/\\caption\{\s*Figure/i)) return match;

            // Extract caption content and wrap properly:
            // - "Figure N." should be bold (not italic)
            // - Rest of caption should be normal text (not italic)
            return `\\begin{figure}${content.replace(
                /\\caption\{([^}]*)\}/,
                (captionMatch: string, captionContent: string) =>
                    `\\caption{\\textnormal{\\textbf{Figure ${figCount}.} ${captionContent}}}`
            )}\\end{figure}`;
        });

        // Resolve all \ref{fig:...} cross-references to just the figure number
        // This handles references like "Figure \ref{fig:flowchart}" -> "Figure 1"
        // By replacing with plain text, we prevent Pandoc from creating hyperlinks
        processedLatex = processedLatex.replace(/\\ref\{(fig:[^}]+|figure:[^}]+)\}/g, (match, label) => {
            const figNum = figureLabelMap.get(label);
            if (figNum) {
                return String(figNum);
            }
            // If label not found, replace with placeholder to avoid showing raw LaTeX
            console.warn(`WARNING: Unresolved figure reference: ${label}`);
            return `?`;
        });

        console.log(`DEBUG: Resolved ${figureLabelMap.size} figure cross-references`);

        // Tables (ThreePartTable, longtable, tabular)
        // We'll iterate through them in order of appearance. 
        // Note: multiple regex passes might miss nested order, but usually tables are top-level.
        // We'll use a single pass for common table environments to keep counter sync if they are mixed.
        // Simplified approach: Match patterns that contain captions and start with table environments.

        let tableCount = 0;
        const tableLabelMap = new Map<string, number>(); // Maps label names to table numbers

        // We'll target the specific environment we know we use: ThreePartTable and longtable
        // But first, let's just create a generic "Table N. " injection for any \caption inside a table-like environment?
        // Actually, let's stick to the specific ones we modify later.

        // Strategy: We are modifying TPT later. Let's modify the captions INSIDE the replacement logic for TPT/longtable to be safe, 
        // OR do it here globally for any \caption inside these blocks.
        // Let's do it globally for simplicity before other replacements.

        // Find all blocks that are likely tables and have captions
        const tableEnvRegex = /(\\begin\{(?:ThreePartTable|longtable|table)\}[\s\S]*?\\end\{(?:ThreePartTable|longtable|table)\})/g;
        processedLatex = processedLatex.replace(tableEnvRegex, (match) => {
            // Only increment if there is a caption
            if (match.includes('\\caption{')) {
                // Check if already numbered
                if (match.match(/\\caption\{\s*Table/i)) return match;

                tableCount++;

                // Extract any \label{tab:...} or \label{table:...} from this table block
                const labelMatch = match.match(/\\label\{(tab:[^}]+|table:[^}]+)\}/);
                if (labelMatch) {
                    tableLabelMap.set(labelMatch[1], tableCount);
                }

                // Inject table number into caption
                return match.replace(/\\caption\{/, `\\caption{Table ${tableCount}. `);
            }
            return match;
        });

        // Resolve all \ref{tab:...} cross-references to just the table number
        // This handles references like "Table \ref{tab:trends}" -> "Table 1"
        processedLatex = processedLatex.replace(/\\ref\{(tab:[^}]+|table:[^}]+)\}/g, (match, label) => {
            const tableNum = tableLabelMap.get(label);
            if (tableNum) {
                return String(tableNum);
            }
            // If label not found, replace with placeholder to avoid showing raw LaTeX
            console.warn(`WARNING: Unresolved table reference: ${label}`);
            return `?`;
        });

        console.log(`DEBUG: Resolved ${tableLabelMap.size} table cross-references`);

        // Extract filecontents bibliography and create separate .bib file
        const bibMatch = latex.match(/\\begin\{filecontents\*?\}(?:\[overwrite\])?\{[^}]*\.bib\}([\s\S]*?)\\end\{filecontents\*?\}/);
        if (bibMatch) {
            await writeFile(bibPath, bibMatch[1].trim(), 'utf-8');
            // Remove filecontents block from latex
            processedLatex = processedLatex.replace(
                /\\begin\{filecontents\*?\}(?:\[overwrite\])?\{[^}]*\.bib\}[\s\S]*?\\end\{filecontents\*?\}/,
                ''
            );
        }

        // Update graphics paths to point to our local figures dir
        // Pandoc needs relatives paths or absolute paths. Since we run pandoc in tempDir, 'figures/Foo.jpg' works if we made correct folder.
        // We ensure "figures/" prefix is respected or added.
        // Actually, if latex has `\includegraphics{figures/foo.jpg}` and we created `tempDir/figures/foo.jpg`, running pandoc in `tempDir` works perfectly.

        // 1. Text Formatting Fixes

        // Prevent "mistakenly italic" - Ensure \textit doesn't leak. 
        // Sometimes unclosed braces or specific environments cause this. 
        // We generally rely on valid LaTeX, but let's check for common issues.

        // 2. Table Fixes

        // GLOBAL: Clean all table column specs BEFORE any table conversion
        // The >{...} modifiers (like >{\raggedright\arraybackslash}) confuse Pandoc 
        // and cause it to strip leading digits from numbers in cells
        // These modifiers always contain backslash commands, so we can safely remove them globally
        // Pattern matches: >{\anything} where anything contains at least one backslash
        processedLatex = processedLatex.replace(/>\{[^}]*\\[^}]*\}/g, '');
        console.log('DEBUG: Removed >{...} column modifiers globally');

        // Convert ThreePartTable: integrate title and notes INTO the table structure
        // This ensures caption and footnotes appear INSIDE the Word table, not outside
        const tptRegex = /\\begin\{ThreePartTable\}([\s\S]*?)\\end\{ThreePartTable\}/g;
        processedLatex = processedLatex.replace(tptRegex, (match, content) => {
            // Extract notes first
            const notesMatch = content.match(/\\begin\{TableNotes\}([\s\S]*?)\\end\{TableNotes\}/);
            let notesText = '';
            if (notesMatch) {
                const rawNotes = notesMatch[1];
                // Process each note item to appear on its own line
                // Convert \item[label] to "label: " at start of line
                // Convert \item to start of new note
                const cleanNotes = rawNotes
                    .replace(/\\small/g, '')
                    .replace(/\\footnotesize/g, '')
                    .replace(/\\scriptsize/g, '')
                    // Convert labeled items: \item[Abbreviations] -> "Abbreviations:"
                    .replace(/\\item\s*\[([^\]]*)\]/g, '\n$1:')
                    // Convert plain items to new lines
                    .replace(/\\item/g, '\n')
                    // Clean up multiple newlines and trim
                    .replace(/\n{2,}/g, '\n')
                    .trim();
                notesText = cleanNotes;
            }

            // Remove TableNotes block
            let tableContent = content
                .replace(/\\begin\{TableNotes\}[\s\S]*?\\end\{TableNotes\}/, '');

            // Extract caption text and label
            const captionMatch = tableContent.match(/\\caption\{([^}]+)\}(\\label\{[^}]+\})?/);
            let captionText = '';
            if (captionMatch) {
                captionText = captionMatch[1];
                // Remove the original caption line
                tableContent = tableContent.replace(/\\caption\{[^}]+\}(\\label\{[^}]+\})?\\\\?\n?/, '');
            }

            // Count columns from the longtable specification
            // Since >{} decorators are removed globally, we can count p{ and simple types
            // Use balanced brace matching to extract full column spec
            let numCols = 4; // default
            const ltStart = tableContent.indexOf('\\begin{longtable}{');
            if (ltStart !== -1) {
                const specStart = ltStart + '\\begin{longtable}{'.length;
                let braceCount = 1;
                let specEnd = specStart;
                while (braceCount > 0 && specEnd < tableContent.length) {
                    if (tableContent[specEnd] === '{') braceCount++;
                    else if (tableContent[specEnd] === '}') braceCount--;
                    specEnd++;
                }
                const spec = tableContent.substring(specStart, specEnd - 1);

                // Count p{...} by counting 'p{' occurrences
                const pCols = (spec.match(/p\{/g) || []).length;
                // Count standalone l, r, c, X (outside of braces)
                const simpleCols = (spec.match(/(?:^|[\s}])([lrcX])(?=[\s{]|$)/g) || []).length;
                numCols = pCols + simpleCols;
                if (numCols === 0) numCols = 4;
            }

            // Remove the entire multi-page header/footer section in one pass
            tableContent = tableContent
                .replace(/\\endfirsthead[\s\S]*?\\endlastfoot/g, '');

            // Also handle standalone markers
            tableContent = tableContent
                .replace(/\\endfirsthead/g, '')
                .replace(/\\endhead/g, '')
                .replace(/\\endfoot/g, '')
                .replace(/\\endlastfoot/g, '')
                .replace(/\\insertTableNotes/g, '');

            // Now inject title as a merged first row after \toprule
            if (captionText) {
                // Insert a merged row for the title right after \toprule
                const titleRow = `\\multicolumn{${numCols}}{l}{\\textbf{\\textit{${captionText}}}} \\\\\n\\midrule\n`;
                tableContent = tableContent.replace(
                    /(\\toprule\n?)/,
                    `$1${titleRow}`
                );
            }

            // Inject notes as a single merged cell before \bottomrule or \end{longtable}
            if (notesText) {
                // Split notes by newlines and format each, then join with \newline
                const noteLines = notesText.split('\n').filter((line: string) => line.trim());
                const formattedLines = noteLines.map((line: string) => {
                    let formattedLine = line.trim();
                    if (formattedLine.startsWith('Note:')) {
                        formattedLine = `\\textit{${formattedLine}}`;
                    } else if (formattedLine.match(/^[A-Z][a-z]*:/)) {
                        // Labels like "Abbreviations:" - make the label bold
                        formattedLine = formattedLine.replace(/^([A-Za-z]+:)/, '\\textbf{$1}');
                    }
                    return formattedLine;
                });

                // Join all lines with \newline to keep them in one cell
                const notesContent = formattedLines.join(' \\newline ');
                const notesRow = `\\midrule\n\\multicolumn{${numCols}}{l}{${notesContent}} \\\\\n`;

                // Try to insert before \bottomrule first
                if (tableContent.includes('\\bottomrule')) {
                    tableContent = tableContent.replace(
                        /\\bottomrule/,
                        `${notesRow}\\bottomrule`
                    );
                } else {
                    // Insert before \end{longtable}
                    tableContent = tableContent.replace(
                        /\\end\{longtable\}/,
                        `${notesRow}\\end{longtable}`
                    );
                }
            }

            return tableContent;
        });

        // Cleanup TPT tags fallback
        processedLatex = processedLatex
            .replace(/\\begin\{ThreePartTable\}/g, '')
            .replace(/\\end\{ThreePartTable\}/g, '');

        // 3. General Cleanup

        // Remove line numbers
        processedLatex = processedLatex
            .replace(/\\usepackage\{lineno\}/g, '')
            .replace(/\\linenumbers/g, '');

        // Cytation styles
        processedLatex = processedLatex.replace(/\\supercite/g, '\\cite');

        // Remove problematic packages
        processedLatex = processedLatex
            .replace(/\\usepackage\{threeparttable\}/g, '')
            .replace(/\\usepackage\{longtable,threeparttablex,booktabs\}/g, '\\usepackage{booktabs}')
            .replace(/\\usepackage\[backend=biber[^\]]*\]\{biblatex\}/g, '')
            .replace(/\\addbibresource\{[^}]+\}/g, '')
            .replace(/\\printbibliography/g, '')
            .replace(/\\usepackage\{authblk\}/g, '');

        // 4. Title Block Injection (Preserving format, preventing leaks)

        interface Author { name: string; affils: string[]; }

        const affilMap = new Map<string, string>();
        const affilRegex = /\\affil\[([^\]]+)\]\{([^}]+)\}/g;
        let affilMatch;
        while ((affilMatch = affilRegex.exec(processedLatex)) !== null) {
            affilMap.set(affilMatch[1], affilMatch[2]);
        }

        const authors: Author[] = [];
        const authorRegex = /\\author\[([^\]]+)\]\{\\textbf\{([^}]+)\}\}/g;
        let authorMatch;
        while ((authorMatch = authorRegex.exec(processedLatex)) !== null) {
            const indices = authorMatch[1].split(',').map(s => s.trim());
            authors.push({ name: authorMatch[2], affils: indices });
        }

        processedLatex = processedLatex
            .replace(/\\author\[[^\]]*\]\{[^}]+\}/g, '')
            .replace(/\\affil\[[^\]]*\]\{[^}]+\}/g, '')
            .replace(/\\maketitle/g, '');

        const titleMatch = processedLatex.match(/\\title\{([^}]+)\}/);
        const titleText = titleMatch ? titleMatch[1] : '';
        processedLatex = processedLatex.replace(/\\title\{[^}]+\}/, '');

        if (titleText) {
            let authorBlock = '';
            if (authors.length > 0) {
                const formattedAuthors = authors.map(a => `${a.name}\\textsuperscript{${a.affils.join(',')}}`).join(', ');
                const formattedAffils = Array.from(affilMap.entries()).map(([key, val]) => `${key}. ${val}`).join('; ');
                authorBlock = `
\\vspace{1em}
${formattedAuthors}

\\vspace{0.5em}
\\textit{${formattedAffils}}
`;
            }

            const titleBlock = `
\\begin{center}
{\\Large\\textbf{${titleText}}}
${authorBlock}
\\end{center}
\\vspace{1.5em}
`;
            processedLatex = processedLatex.replace(/\\begin\{document\}/, '\\begin{document}\n' + titleBlock);
        }

        // 5. Heading Formatting
        // Ensure section commands are surrounded by blank lines for proper spacing
        // Keep the \section and \section* commands intact so Pandoc converts them to Word headings
        // Just add blank lines around them to prevent spacing issues
        processedLatex = processedLatex.replace(
            /(\n?)\\section\*?\{([^}]+)\}(\n?)/g,
            '\n\n\\section*{$2}\n\n'
        );

        // Handle subsections similarly
        processedLatex = processedLatex.replace(
            /(\n?)\\subsection\*?\{([^}]+)\}(\n?)/g,
            '\n\n\\subsection*{$2}\n\n'
        );

        // Handle subsubsections
        processedLatex = processedLatex.replace(
            /(\n?)\\subsubsection\*?\{([^}]+)\}(\n?)/g,
            '\n\n\\subsubsection*{$2}\n\n'
        );

        // Write processed LaTeX
        await writeFile(texPath, processedLatex, 'utf-8');

        // DEBUG: Also write to a debug file in temp so we can inspect
        await writeFile(join(tempDir, 'debug_processed.tex'), processedLatex, 'utf-8');
        console.log('DEBUG: Wrote processed LaTeX to', join(tempDir, 'debug_processed.tex'));

        // Create a modified reference.docx with all detected styles
        const customRefPath = join(tempDir, 'custom-reference.docx');
        try {
            // Copy and modify the reference document to use detected styles
            const refBuffer = await readFile(REFERENCE_DOC_PATH);
            await writeFile(customRefPath, refBuffer);

            // Extract the docx (which is a zip file)
            const extractDir = join(tempDir, 'ref-extract');
            await mkdir(extractDir, { recursive: true });
            await execAsync(`unzip -o "${customRefPath}" -d "${extractDir}"`, { timeout: 10000 });

            // ============================================================
            // Modify styles.xml - font, font size, line spacing, paragraph
            // ============================================================
            const stylesPath = join(extractDir, 'word', 'styles.xml');
            let stylesContent = await readFile(stylesPath, 'utf-8');

            // 1. Replace theme-based fonts with detected font
            stylesContent = stylesContent
                .replace(/w:asciiTheme="minorHAnsi"/g, `w:ascii="${detectedFont}"`)
                .replace(/w:hAnsiTheme="minorHAnsi"/g, `w:hAnsi="${detectedFont}"`)
                .replace(/w:asciiTheme="majorHAnsi"/g, `w:ascii="${detectedFont}"`)
                .replace(/w:hAnsiTheme="majorHAnsi"/g, `w:hAnsi="${detectedFont}"`)
                .replace(/w:cstheme="minorBidi"/g, `w:cs="${detectedFont}"`)
                .replace(/w:cstheme="majorBidi"/g, `w:cs="${detectedFont}"`);

            // 2. Update font size in run properties defaults
            // Replace default font size (w:sz and w:szCs) in docDefaults
            stylesContent = stylesContent.replace(
                /(<w:rPrDefault>[\s\S]*?<w:sz\s+w:val=")(\d+)(")/,
                `$1${detectedFontSizeHalfPt}$3`
            );
            stylesContent = stylesContent.replace(
                /(<w:rPrDefault>[\s\S]*?<w:szCs\s+w:val=")(\d+)(")/,
                `$1${detectedFontSizeHalfPt}$3`
            );

            // 3. Add line spacing and paragraph formatting to BodyText style
            // First, check if BodyText style has a pPr section
            if (stylesContent.includes('w:styleId="BodyText"')) {
                // Construct the paragraph properties we want
                const pPrContent = `<w:spacing w:after="${detectedParSkip}" w:line="${detectedLineSpacing}" w:lineRule="auto"/>` +
                    (detectedParIndent === 0 ? `<w:ind w:firstLine="0"/>` : `<w:ind w:firstLine="${detectedParIndent}"/>`);

                // Check if BodyText already has <w:pPr>
                const bodyTextMatch = stylesContent.match(/<w:style[^>]*w:styleId="BodyText"[^>]*>([\s\S]*?)<\/w:style>/);
                if (bodyTextMatch) {
                    const bodyTextContent = bodyTextMatch[0];
                    if (bodyTextContent.includes('<w:pPr>')) {
                        // Replace existing pPr content
                        stylesContent = stylesContent.replace(
                            /(<w:style[^>]*w:styleId="BodyText"[^>]*>[\s\S]*?<w:pPr>)([\s\S]*?)(<\/w:pPr>)/,
                            `$1${pPrContent}$3`
                        );
                    } else {
                        // Insert new pPr before </w:style> for BodyText
                        stylesContent = stylesContent.replace(
                            /(<w:style[^>]*w:styleId="BodyText"[^>]*>[\s\S]*?)(<\/w:style>)/,
                            `$1<w:pPr>${pPrContent}</w:pPr>$2`
                        );
                    }
                }
            }

            // 4. Also update Normal style with same paragraph properties for consistency
            if (stylesContent.includes('w:styleId="Normal"')) {
                const pPrContent = `<w:spacing w:after="${detectedParSkip}" w:line="${detectedLineSpacing}" w:lineRule="auto"/>` +
                    (detectedParIndent === 0 ? `<w:ind w:firstLine="0"/>` : `<w:ind w:firstLine="${detectedParIndent}"/>`);

                const normalMatch = stylesContent.match(/<w:style[^>]*w:styleId="Normal"[^>]*>([\s\S]*?)<\/w:style>/);
                if (normalMatch) {
                    const normalContent = normalMatch[0];
                    if (normalContent.includes('<w:pPr>')) {
                        stylesContent = stylesContent.replace(
                            /(<w:style[^>]*w:styleId="Normal"[^>]*>[\s\S]*?<w:pPr>)([\s\S]*?)(<\/w:pPr>)/,
                            `$1${pPrContent}$3`
                        );
                    } else {
                        // Insert pPr after the opening tag elements
                        stylesContent = stylesContent.replace(
                            /(<w:style[^>]*w:styleId="Normal"[^>]*>[\s\S]*?<w:qFormat\s*\/>)/,
                            `$1<w:pPr>${pPrContent}</w:pPr>`
                        );
                    }
                }
            }

            // 5. Remove italics from ImageCaption style (figure captions should not be italic)
            // The ImageCaption style is used by Pandoc for figure captions
            // We need to remove any <w:i/> or <w:iCs/> elements from its rPr section
            if (stylesContent.includes('w:styleId="ImageCaption"')) {
                // Remove italic tags from ImageCaption style's run properties
                stylesContent = stylesContent.replace(
                    /(<w:style[^>]*w:styleId="ImageCaption"[^>]*>[\s\S]*?<w:rPr>)([\s\S]*?)(<\/w:rPr>)/,
                    (match: string, before: string, rPrContent: string, after: string) => {
                        // Remove <w:i/> and <w:iCs/> from the run properties
                        const cleanedRPr = rPrContent
                            .replace(/<w:i\/>/g, '')
                            .replace(/<w:iCs\/>/g, '')
                            .replace(/<w:i\s+[^>]*\/>/g, '')
                            .replace(/<w:iCs\s+[^>]*\/>/g, '');
                        return before + cleanedRPr + after;
                    }
                );
            }

            // 6. Similarly remove italics from Caption style (generic caption style)
            if (stylesContent.includes('w:styleId="Caption"')) {
                stylesContent = stylesContent.replace(
                    /(<w:style[^>]*w:styleId="Caption"[^>]*>[\s\S]*?<w:rPr>)([\s\S]*?)(<\/w:rPr>)/,
                    (match: string, before: string, rPrContent: string, after: string) => {
                        const cleanedRPr = rPrContent
                            .replace(/<w:i\/>/g, '')
                            .replace(/<w:iCs\/>/g, '')
                            .replace(/<w:i\s+[^>]*\/>/g, '')
                            .replace(/<w:iCs\s+[^>]*\/>/g, '');
                        return before + cleanedRPr + after;
                    }
                );
            }

            // 7. Normalize all Heading styles to use same font, size, and color
            // This ensures section/subsection/subsubsection all look consistent
            const headingStyles = ['Heading1', 'Heading2', 'Heading3', 'Heading4', 'Heading5', 'Heading6'];

            // Build the run properties for headings: same font, size, and black color
            const headingRPr = `<w:rFonts w:ascii="${detectedFont}" w:hAnsi="${detectedFont}" w:cs="${detectedFont}"/>` +
                `<w:b/><w:bCs/>` + // Bold
                `<w:sz w:val="${detectedFontSizeHalfPt}"/>` +
                `<w:szCs w:val="${detectedFontSizeHalfPt}"/>` +
                `<w:color w:val="000000"/>`; // Black color

            for (const headingId of headingStyles) {
                const headingRegex = new RegExp(`(<w:style[^>]*w:styleId="${headingId}"[^>]*>)([\\s\\S]*?)(</w:style>)`);
                const headingMatch = stylesContent.match(headingRegex);

                if (headingMatch) {
                    let styleContent = headingMatch[2];

                    // Check if style has rPr section
                    if (styleContent.includes('<w:rPr>')) {
                        // Replace existing rPr content with our normalized heading styles
                        styleContent = styleContent.replace(
                            /<w:rPr>[\s\S]*?<\/w:rPr>/,
                            `<w:rPr>${headingRPr}</w:rPr>`
                        );
                    } else {
                        // Insert rPr before the closing style tag
                        styleContent = styleContent + `<w:rPr>${headingRPr}</w:rPr>`;
                    }

                    // Replace the heading style in the full content
                    stylesContent = stylesContent.replace(
                        headingRegex,
                        `$1${styleContent}$3`
                    );
                }
            }

            console.log('DEBUG: Normalized heading styles to use same font, size, and color');

            await writeFile(stylesPath, stylesContent, 'utf-8');

            // ============================================================
            // Modify document.xml - section properties for margins
            // ============================================================
            const documentPath = join(extractDir, 'word', 'document.xml');
            let documentContent = await readFile(documentPath, 'utf-8');

            // Find <w:sectPr> and update margins
            // Word margins: w:top, w:right, w:bottom, w:left (all in twips)
            const marginXml = `<w:pgMar w:top="${detectedMargins.top}" w:right="${detectedMargins.right}" w:bottom="${detectedMargins.bottom}" w:left="${detectedMargins.left}" w:header="720" w:footer="720" w:gutter="0"/>`;

            // Replace existing pgMar or insert if missing
            if (documentContent.includes('<w:pgMar')) {
                documentContent = documentContent.replace(
                    /<w:pgMar[^>]*\/>/g,
                    marginXml
                );
            } else if (documentContent.includes('<w:sectPr>')) {
                documentContent = documentContent.replace(
                    /<w:sectPr>/g,
                    `<w:sectPr>${marginXml}`
                );
            }

            await writeFile(documentPath, documentContent, 'utf-8');

            // Repack the docx
            await execAsync(`cd "${extractDir}" && zip -r "${customRefPath}" .`, { timeout: 10000 });
            console.log(`DEBUG: Created custom reference.docx with all detected styles`);
        } catch (refErr) {
            console.warn('Failed to create custom reference doc, using default:', refErr);
            // Fall back to original reference doc
            await writeFile(customRefPath, await readFile(REFERENCE_DOC_PATH));
        }

        // Build Pandoc command
        let success = false;
        let pandocOutput = '';

        // Base args - use the custom reference doc with injected font
        const commonArgs = [
            `"${texPath}"`,
            '-f', 'latex+smart',
            '-t', 'docx',
            '-o', `"${docxPath}"`,
            '--standalone',
            `--reference-doc="${customRefPath}"`,
            // Essential for image handling:
            '--resource-path=.',
        ];

        if (bibMatch) {
            try {
                const citeprocCmd = [
                    'pandoc',
                    ...commonArgs,
                    '--citeproc',
                    `--bibliography="${bibPath}"`,
                    `--csl="${NEJM_CSL_PATH}"`,
                ].join(' ');

                console.log('Running Pandoc (citeproc):', citeprocCmd);
                const { stderr } = await execAsync(citeprocCmd, { cwd: tempDir, timeout: 60000 });
                if (stderr) console.warn('Pandoc stderr:', stderr);
                success = true;
                pandocOutput = 'citeproc';
            } catch (err: unknown) {
                const execError = err as { stderr?: string; message?: string };
                console.warn('Citeproc failed, fallback to simple:', execError.stderr || execError.message || err);
            }
        }

        if (!success) {
            const simpleCmd = [
                'pandoc',
                ...commonArgs,
            ].join(' ');

            console.log('Running Pandoc (simple):', simpleCmd);
            const { stderr } = await execAsync(simpleCmd, { cwd: tempDir, timeout: 60000 });
            if (stderr) console.warn('Pandoc stderr:', stderr);
            pandocOutput = 'simple';
        }

        console.log('Pandoc conversion completed:', pandocOutput);

        // Post-process the DOCX to apply booktabs-style table borders
        // LaTeX booktabs uses horizontal rules only: \toprule, \midrule, \bottomrule
        // No vertical borders
        try {
            const docxExtractDir = join(tempDir, 'docx-extract');
            await mkdir(docxExtractDir, { recursive: true });
            await execAsync(`unzip -o "${docxPath}" -d "${docxExtractDir}"`, { timeout: 10000 });

            const docxDocPath = join(docxExtractDir, 'word', 'document.xml');
            let docxContent = await readFile(docxDocPath, 'utf-8');

            // Find all tables and apply booktabs-style borders
            // Remove all vertical borders (w:left, w:right, w:insideV)
            // Keep only horizontal borders (w:top, w:bottom, w:insideH)

            // Pattern to match tblBorders element
            // Replace existing tblBorders with booktabs style
            const booktabsBorders = `<w:tblBorders>` +
                `<w:top w:val="single" w:sz="12" w:space="0" w:color="000000"/>` +
                `<w:bottom w:val="single" w:sz="12" w:space="0" w:color="000000"/>` +
                `<w:insideH w:val="single" w:sz="6" w:space="0" w:color="000000"/>` +
                `</w:tblBorders>`;

            // Replace any existing tblBorders
            docxContent = docxContent.replace(/<w:tblBorders>[\s\S]*?<\/w:tblBorders>/g, booktabsBorders);

            // Also ensure table cells don't have individual borders that override table borders
            // Remove cell-level borders (tcBorders) to let table-level borders take precedence
            docxContent = docxContent.replace(/<w:tcBorders>[\s\S]*?<\/w:tcBorders>/g, '');

            // Remove italics from figure captions (ImageCaption paragraphs)
            // Find paragraphs with ImageCaption style and remove <w:i/> and <w:iCs/> from their runs
            docxContent = docxContent.replace(
                /(<w:p[^>]*>[\s\S]*?<w:pStyle w:val="ImageCaption"\/>[\s\S]*?)(<w:r>[\s\S]*?<\/w:r>)/g,
                (match: string) => {
                    // Remove italic tags from all run properties in this paragraph
                    return match
                        .replace(/<w:i\/>/g, '')
                        .replace(/<w:iCs\/>/g, '')
                        .replace(/<w:i\s+[^>]*\/>/g, '')
                        .replace(/<w:iCs\s+[^>]*\/>/g, '');
                }
            );

            // Also handle Caption style paragraphs
            docxContent = docxContent.replace(
                /(<w:p[^>]*>[\s\S]*?<w:pStyle w:val="Caption"\/>[\s\S]*?)(<w:r>[\s\S]*?<\/w:r>)/g,
                (match: string) => {
                    return match
                        .replace(/<w:i\/>/g, '')
                        .replace(/<w:iCs\/>/g, '')
                        .replace(/<w:i\s+[^>]*\/>/g, '')
                        .replace(/<w:iCs\s+[^>]*\/>/g, '');
                }
            );

            // Global cleanup: Remove all italics from any paragraph containing "Figure" followed by a number
            // This is a fallback to catch any captions not caught by style-based matching
            docxContent = docxContent.replace(
                /<w:p[^>]*>[\s\S]*?<w:t[^>]*>Figure\s+\d+[\s\S]*?<\/w:p>/g,
                (match: string) => {
                    return match
                        .replace(/<w:i\/>/g, '')
                        .replace(/<w:iCs\/>/g, '')
                        .replace(/<w:i\s+[^>]*\/>/g, '')
                        .replace(/<w:iCs\s+[^>]*\/>/g, '');
                }
            );

            // Add line numbers to the section properties
            // Line numbers restart on each page, appear in the left margin
            const lineNumXml = `<w:lnNumType w:countBy="1" w:restart="continuous"/>`;

            // Find sectPr elements and add line numbering if not present
            if (docxContent.includes('<w:sectPr')) {
                // Check if lnNumType already exists
                if (!docxContent.includes('<w:lnNumType')) {
                    // Insert line numbering after the opening <w:sectPr> or after <w:pgSz>/<w:pgMar>
                    docxContent = docxContent.replace(
                        /(<w:sectPr[^>]*>)/g,
                        `$1${lineNumXml}`
                    );
                    console.log('DEBUG: Added line numbers to sectPr');
                }
            }

            // Add page numbers via footer
            // We need to: 1) Create footer file if not exists, 2) Add footerReference to sectPr
            // Check if there's already a footer relationship
            const relsPath = join(docxExtractDir, 'word', '_rels', 'document.xml.rels');
            let relsContent = '';
            try {
                relsContent = await readFile(relsPath, 'utf-8');
            } catch {
                // No rels file, create one
                relsContent = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>`;
            }

            // Check if footer1.xml already exists
            const footer1Path = join(docxExtractDir, 'word', 'footer1.xml');
            let footerExists = false;
            let footerRId = 'rId999';

            // Find existing footer reference
            const existingFooterMatch = relsContent.match(/Id="(rId\d+)"[^>]*Target="footer\d+\.xml"/);
            if (existingFooterMatch) {
                footerExists = true;
                footerRId = existingFooterMatch[1];
                console.log(`DEBUG: Footer already exists with ${footerRId}`);
            } else {
                // Find the highest rId in use and add 1
                const rIdMatches = relsContent.match(/rId(\d+)/g) || [];
                let maxId = 0;
                for (const match of rIdMatches) {
                    const num = parseInt(match.replace('rId', ''));
                    if (num > maxId) maxId = num;
                }
                footerRId = `rId${maxId + 1}`;
            }

            // Create footer XML with centered page number
            const footerXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:ftr xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <w:p>
    <w:pPr>
      <w:jc w:val="center"/>
    </w:pPr>
    <w:r>
      <w:fldChar w:fldCharType="begin"/>
    </w:r>
    <w:r>
      <w:instrText>PAGE</w:instrText>
    </w:r>
    <w:r>
      <w:fldChar w:fldCharType="separate"/>
    </w:r>
    <w:r>
      <w:t>1</w:t>
    </w:r>
    <w:r>
      <w:fldChar w:fldCharType="end"/>
    </w:r>
  </w:p>
</w:ftr>`;

            if (!footerExists) {
                // Write footer file
                await writeFile(footer1Path, footerXml, 'utf-8');
                console.log('DEBUG: Created footer1.xml with page number');

                // Add relationship to rels file
                const newRel = `<Relationship Id="${footerRId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer" Target="footer1.xml"/>`;
                relsContent = relsContent.replace(
                    '</Relationships>',
                    `${newRel}\n</Relationships>`
                );
                await writeFile(relsPath, relsContent, 'utf-8');

                // Add footer to [Content_Types].xml
                const contentTypesPath = join(docxExtractDir, '[Content_Types].xml');
                let contentTypes = await readFile(contentTypesPath, 'utf-8');
                if (!contentTypes.includes('footer1.xml')) {
                    contentTypes = contentTypes.replace(
                        '</Types>',
                        `<Override PartName="/word/footer1.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml"/>\n</Types>`
                    );
                    await writeFile(contentTypesPath, contentTypes, 'utf-8');
                }
            }

            // Add footerReference to sectPr if not present
            if (!docxContent.includes('<w:footerReference')) {
                const footerRef = `<w:footerReference w:type="default" r:id="${footerRId}"/>`;
                // Insert after sectPr opening tag
                docxContent = docxContent.replace(
                    /(<w:sectPr[^>]*>)/g,
                    `$1${footerRef}`
                );

                // Ensure the 'r' namespace is declared in the document element
                if (!docxContent.includes('xmlns:r=')) {
                    docxContent = docxContent.replace(
                        /<w:document /,
                        '<w:document xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" '
                    );
                }
                console.log(`DEBUG: Added footer reference ${footerRId} to sectPr`);
            }

            // Move all tables and figures to the end of the document to match submission-style Word layouts
            try {
                const bodyMatch = docxContent.match(/<w:body>([\s\S]*?)<\/w:body>/);
                if (bodyMatch) {
                    const bodyContent = bodyMatch[1];
                    const sectPrMatch = bodyContent.match(/<w:sectPr[\s\S]*?<\/w:sectPr>/);
                    const sectPr = sectPrMatch ? sectPrMatch[0] : '';
                    const bodyWithoutSectPr = sectPr ? bodyContent.replace(sectPr, '') : bodyContent;

                    const blockRegex = /<w:p[^>]*>[\s\S]*?<\/w:p>|<w:tbl[^>]*>[\s\S]*?<\/w:tbl>|<w:bookmarkStart[^>]*\/>|<w:bookmarkEnd[^>]*\/>/g;
                    const blocks = bodyWithoutSectPr.match(blockRegex) || [];

                    const remainingBlocks: string[] = [];
                    const tableBlocks: string[] = [];
                    const figureBlocks: string[] = [];

                    const pageBreakParagraph = '<w:p><w:r><w:br w:type="page"/></w:r></w:p>';
                    const headingParagraph = (text: string) =>
                        `<w:p><w:pPr><w:pStyle w:val="BodyText"/></w:pPr><w:r><w:rPr><w:b/><w:bCs/></w:rPr><w:t xml:space="preserve">${text}</w:t></w:r></w:p>`;

                    const collectBookmarkGroup = (startIndex: number, id: string) => {
                        const collected: string[] = [];
                        let endIndex = startIndex;
                        for (; endIndex < blocks.length; endIndex++) {
                            collected.push(blocks[endIndex]);
                            if (blocks[endIndex].includes(`<w:bookmarkEnd w:id="${id}"`)) {
                                break;
                            }
                        }
                        return { collected, endIndex };
                    };

                    const isTableCaption = (block: string) => /w:pStyle w:val="TableCaption"/.test(block);
                    const isFigureCaption = (block: string) => /w:pStyle w:val="ImageCaption"/.test(block);
                    const hasDrawing = (block: string) => /<w:drawing/.test(block);

                    for (let i = 0; i < blocks.length; i++) {
                        const block = blocks[i];

                        const bookmarkStartMatch = block.match(/<w:bookmarkStart[^>]*w:id="([^"]+)"[^>]*w:name="([^"]+)"/);
                        if (bookmarkStartMatch) {
                            const [, id, name] = bookmarkStartMatch;
                            if (name.startsWith('fig:') || name.startsWith('figure:')) {
                                const { collected, endIndex } = collectBookmarkGroup(i, id);
                                figureBlocks.push(collected.join(''));
                                i = endIndex;
                                continue;
                            }
                            if (name.startsWith('tab:') || name.startsWith('table:')) {
                                const { collected, endIndex } = collectBookmarkGroup(i, id);
                                tableBlocks.push(collected.join(''));
                                i = endIndex;
                                continue;
                            }
                        }

                        if (isTableCaption(block) && blocks[i + 1]?.startsWith('<w:tbl')) {
                            const target = blocks[i + 1].includes('FigureTable') ? figureBlocks : tableBlocks;
                            target.push(block + blocks[i + 1]);
                            i += 1;
                            continue;
                        }

                        if (block.startsWith('<w:tbl')) {
                            const target = block.includes('FigureTable') ? figureBlocks : tableBlocks;
                            target.push(block);
                            continue;
                        }

                        if (hasDrawing(block)) {
                            const figureGroup = [block];
                            if (blocks[i + 1] && isFigureCaption(blocks[i + 1])) {
                                figureGroup.push(blocks[i + 1]);
                                i += 1;
                            }
                            figureBlocks.push(figureGroup.join(''));
                            continue;
                        }

                        remainingBlocks.push(block);
                    }

                    if (tableBlocks.length > 0 || figureBlocks.length > 0) {
                        // Section break that ends main text section WITH line numbers
                        // This applies to all preceding content (main text) - so it MUST have line numbers
                        const sectionBreakWithLineNums = `<w:p><w:pPr><w:sectPr><w:type w:val="nextPage"/><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="${detectedMargins.top}" w:right="${detectedMargins.right}" w:bottom="${detectedMargins.bottom}" w:left="${detectedMargins.left}" w:header="720" w:footer="720" w:gutter="0"/><w:lnNumType w:countBy="1" w:restart="continuous"/><w:footerReference w:type="default" r:id="${footerRId}"/></w:sectPr></w:pPr></w:p>`;

                        // Section break WITHOUT line numbers (for table/figure sections)
                        const sectionBreakNoLineNums = `<w:p><w:pPr><w:sectPr><w:type w:val="nextPage"/><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="${detectedMargins.top}" w:right="${detectedMargins.right}" w:bottom="${detectedMargins.bottom}" w:left="${detectedMargins.left}" w:header="720" w:footer="720" w:gutter="0"/><w:footerReference w:type="default" r:id="${footerRId}"/></w:sectPr></w:pPr></w:p>`;

                        const reorderedBodyParts = [
                            ...remainingBlocks,
                            // End the main text section WITH line numbers
                            sectionBreakWithLineNums,
                        ];

                        // Add each table on its own page (section without line numbers)
                        if (tableBlocks.length > 0) {
                            for (let t = 0; t < tableBlocks.length; t++) {
                                // Add table heading only for the first table
                                if (t === 0) {
                                    reorderedBodyParts.push(headingParagraph('Tables'));
                                }
                                reorderedBodyParts.push(tableBlocks[t]);
                                // Add section break AFTER each table (except the last one if no figures follow)
                                if (t < tableBlocks.length - 1 || figureBlocks.length > 0) {
                                    reorderedBodyParts.push(sectionBreakNoLineNums);
                                }
                            }
                        }

                        // Add each figure on its own page (section without line numbers)
                        if (figureBlocks.length > 0) {
                            // If there were tables, we already added a section break after the last table
                            // Otherwise we need to mark that figures section starts
                            for (let f = 0; f < figureBlocks.length; f++) {
                                // Add figure heading only for the first figure
                                if (f === 0) {
                                    reorderedBodyParts.push(headingParagraph('Figures'));
                                }
                                reorderedBodyParts.push(figureBlocks[f]);
                                // Add section break AFTER each figure (except the last one)
                                if (f < figureBlocks.length - 1) {
                                    reorderedBodyParts.push(sectionBreakNoLineNums);
                                }
                            }
                        }

                        // The final sectPr (at document end) should also have no line numbers for the last figure/table section
                        // Modify the original sectPr to remove line numbers
                        let finalSectPr = sectPr;
                        if (finalSectPr) {
                            // Remove any existing lnNumType from the final section
                            finalSectPr = finalSectPr.replace(/<w:lnNumType[^>]*\/>/g, '');
                        }

                        const newBody = reorderedBodyParts.join('\n') + (finalSectPr ? `\n${finalSectPr}` : '');
                        docxContent = docxContent.replace(/<w:body>[\s\S]*<\/w:body>/, `<w:body>${newBody}</w:body>`);
                    }
                }
            } catch (reorderErr) {
                console.warn('Failed to reorder tables/figures to end of Word document:', reorderErr);
            }

            await writeFile(docxDocPath, docxContent, 'utf-8');

            // Repack the docx
            await execAsync(`cd "${docxExtractDir}" && zip -r "${docxPath}" .`, { timeout: 10000 });
            console.log('DEBUG: Applied booktabs-style table borders to DOCX');
        } catch (borderErr) {
            console.warn('Failed to apply table border styling:', borderErr);
            // Continue with the original DOCX
        }

        // Read DOCX
        const docxBuffer = await readFile(docxPath);

        // Cleanup
        await Promise.all([
            // Remove the specific UUID dir we created
            // We use rm -rf equivalent for directories in node 14+ via rmdir or rm
            // But here we can just use readdir/unlink manually or rely on OS temp cleanup eventually
            // Let's at least try to remove the files we created
            unlink(texPath).catch(() => { }),
            unlink(bibPath).catch(() => { }),
            unlink(docxPath).catch(() => { }),
            // Ideally we'd remove figures dir and tempDir too, but fs/promises rm is Node 14.14+
            // We'll leave the random dir for simple logic or need a recursive delete helper
        ]);

        // Try recursive delete of tempDir (Node 14.14+)
        /*
        try {
           await fs.rm(tempDir, { recursive: true, force: true });
        } catch(e) {}
        */

        return new NextResponse(docxBuffer, {
            status: 200,
            headers: {
                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'Content-Disposition': `attachment; filename="${filename}.docx"`,
            },
        });

    } catch (error) {
        console.error('Pandoc conversion error:', error);
        // Attempt cleanup?

        // Extract actual error message - exec errors often have stderr property
        const execError = error as { stderr?: string; message?: string; stdout?: string };
        let errorMessage = 'Unknown error';

        if (execError.stderr) {
            // Pandoc errors are in stderr - use that
            errorMessage = execError.stderr.trim();
        } else if (execError.message) {
            errorMessage = execError.message;
        }

        // If error message contains the whole command, try to extract just the error part
        if (errorMessage.includes('Command failed:') && execError.stderr) {
            errorMessage = execError.stderr.trim();
        }

        if (errorMessage.includes('pandoc') && (errorMessage.includes('not found') || errorMessage.includes('No such file'))) {
            return NextResponse.json(
                { error: 'Pandoc is not installed on the server.' },
                { status: 500 }
            );
        }

        return NextResponse.json(
            { error: `Conversion failed: ${errorMessage}` },
            { status: 500 }
        );
    }
}
